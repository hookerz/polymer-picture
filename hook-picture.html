<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../polymer/lib/utils/flattened-nodes-observer.html">
<link rel="import" href="./hook-picture-source.html">
<!--
`<hook-picture>` is a picture element that mimics the HTML5 `<picture>` element.  Use iron-image, img or don't include an image to use a div with a background-image.  Just include what media queries you wish to use and the element will adjust to your needs.

### Example:

    // Using an image
    <hook-picture>
      <hook-picture-source src="http://placehold.it/1000x150" media="(min-width: 1000px)"></hook-picture-source>
      <hook-picture-source src="http://placehold.it/600x150" media="(min-width: 600px)"></hook-picture-source>
      <img src="http://placehold.it/350x150" alt="image" default>
    </hook-picture>

    // Using an iron image
    <hook-picture>
      <hook-picture-source src="http://placehold.it/1000x150" media="(min-width: 1000px)"></hook-picture-source>
      <hook-picture-source src="http://placehold.it/600x150" media="(min-width: 600px)"></hook-picture-source>
      <iron-image src="http://placehold.it/350x150" alt="image" default></iron-image>
    </hook-picture>

    // Using a background image
    <hook-picture src="http://placehold.it/350x150">
      <hook-picture-source src="http://placehold.it/1000x150" media="(min-width: 1000px)"></hook-picture-source>
      <hook-picture-source src="http://placehold.it/600x150" media="(min-width: 600px)"></hook-picture-source>
    </hook-picture>

### Styling

The following custom properties and mixins are available for styling:

Custom property | Description | Default
----------------|-------------|----------
`--hook-picture` | Mixin applied to the element | `{}`

@element hook-picture
@demo demo/index.html
-->

<dom-module id="hook-picture">

  <template>

    <style>
      :host {
        display: inherit;
        @apply (--hook-picture);
      }

      :not([_ready])::slotted(*) {
        display: none;
      }
    </style>

    <slot id="slot" _ready$="[[_ready]]"></slot>

  </template>

  <script>
    class HookPicture extends Polymer.Element {
      static get is() {
        return 'hook-picture';
      }

      static get properties() {
        return {
          src: {
            type: String,
            notify: true,
            reflectToAttribute: true
          },
          activeNode: {
            type: Object,
            notify: true
          },
          active: {
            type: Boolean,
            reflectToAttribute: true,
            value: false
          },
          _ready : {
            type: Boolean,
            value: false
          },
          fallbackSrc: {
            type: String,
            notify: true
          },
          _boundQueryMatchHandler: {
            type: Function,
            value: function() {
              return this._queryMatchesChanged.bind(this);
            }
          },
          nodes: {
            type:Array,
            value: () => {
              return [];
            }
          }
        }
      }

      connectedCallback() {
        super.connectedCallback();
        this._ready = true;
        this._observer = new Polymer.FlattenedNodesObserver(this.$.slot, (info) => {
          this._processNewNodes(info.addedNodes);
          this._processRemovedNodes(info.removedNodes);
        });
        let nodes = Polymer.FlattenedNodesObserver.getFlattenedNodes(this.$.slot);
        let fallbackSrc = this.fallbackSrc;
        let otherNodes = HookPicture.getOtherNodes(nodes);
        for(let i = 0; i < otherNodes.length; i++) {
          let node = otherNodes[i];
          if(node.hasAttribute('src')) {
            fallbackSrc = node.src;
          }
        }
        if(fallbackSrc !== null) {
          this.fallbackSrc = fallbackSrc;
        }
        this._processNewNodes(nodes);
      }

      disconnectedCallback() {
        super.disconnectedCallback();
        this._observer.disconnect();
      }

      _queryMatchesChanged() {
        Polymer.RenderStatus.beforeNextRender(this, this._calculateImagePath);
      }

      /**
      * Loop through the inner nodes and find the first media query that matches.
      * If none match, use the fallback, if set.
      */
      _calculateImagePath() {
        let activeNode = null;
        let nodes = HookPicture.getSourceNodes(this.nodes);
        for(let i = 0; i < nodes.length; i++) {
          let node = nodes[i];
          if(node.queryMatches) {
            activeNode = node;
            break;
          }
        }
        if(activeNode) {
          this.setProperties({
            src: activeNode.src,
            activeNode: activeNode,
            active: true
          });
        }
        else {
          this.setProperties({
            src: this.fallbackSrc,
            activeNode: null,
            active: false
          });
        }

        var otherNodes = HookPicture.getOtherNodes(this.nodes);
        for(let i = 0; i < otherNodes.length; i++) {
          let node = otherNodes[i];

          //set the source to the inner nodes.
          if(this.src) {
            node.src = this.src;
          }
          //if the fallback isn't specified, we remove the src attribute off the node.
          else {
            node.removeAttribute('src');
          }
        }
      }

      /*
      * Processes newly added nodes and caches them. Only accepts Element nodes.
      * Listens to the new nodes for query changes.
      */
      _processNewNodes(nodes) {
         nodes.filter(function(node) {
          return (node.nodeType === Node.ELEMENT_NODE)
        }).forEach(function(node) {
          if(node instanceof HookPictureSource) {
            node.addEventListener('query-matches-changed', this._boundQueryMatchHandler);
          }
          this.nodes.push(node);
        }.bind(this));
        this.notifyPath('nodes');
        Polymer.RenderStatus.beforeNextRender(this, this._calculateImagePath);
      }

      _processRemovedNodes(nodes) {
        nodes.filter(function(node) {
          return (node.nodeType === Node.ELEMENT_NODE)
        }).forEach(function(node) {
          if(node instanceof HookPictureSource) {
            node.removeEventListener('query-matches-changed', this._boundQueryMatchHandler);
          }
          var index = this.nodes.indexOf(node);
          if(index) {
            this.nodes.splice(index, 1);
          }
        }.bind(this));
        this.notifyPath('nodes');
        Polymer.RenderStatus.beforeNextRender(this, this._calculateImagePath);
      }

      static getSourceNodes(nodes) {
        return nodes.filter(function(node) {
          return (node.nodeType === Node.ELEMENT_NODE) && (node instanceof HookPictureSource)
        })
      }

      static getOtherNodes(nodes) {
        return nodes.filter(function(node) {
          return (node.nodeType === Node.ELEMENT_NODE) && (!(node instanceof HookPictureSource))
        })
      }

    }
    window.customElements.define(HookPicture.is, HookPicture);
  </script>

</dom-module>
